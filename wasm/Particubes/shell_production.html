<!doctype html>
<html lang="en-us" style="width: 100%; height: 100%;">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Cubzh</title>
    <style>
      @font-face {
        font-family: "monogram_extended";
        src: url('monogram_extended.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }

      /* CSS-reset */
      html, body, div, span, applet, object, iframe,
      h1, h2, h3, h4, h5, h6, p, blockquote, pre,
      a, abbr, acronym, address, big, cite, code,
      del, dfn, em, img, ins, kbd, q, s, samp,
      small, strike, strong, sub, sup, tt, var,
      b, u, i, center,
      dl, dt, dd, ol, ul, li,
      fieldset, form, label, legend,
      table, caption, tbody, tfoot, thead, tr, th, td,
      article, aside, canvas, details, embed,
      figure, figcaption, footer, header, hgroup,
      menu, nav, output, ruby, section, summary,
      time, mark, audio, video {
        margin: 0;
        padding: 0;
        border: 0;
      }

      /* HTML5 display-role reset for older browsers */
      article, aside, details, figcaption, figure,
      footer, header, hgroup, menu, nav, section {
        display: block;
      }

      html {
        font-family: 'monogram_extended', monospace;
        vertical-align: baseline;
        background-color: #333333;
      }

      body {
        width: 100%;
        height: 100%;
        background-color: #333333;
      }

      ol, ul {
        list-style: none;
      }
      blockquote, q {
        quotes: none;
      }
      blockquote:before, blockquote:after,
      q:before, q:after {
        content: '';
        content: none;
      }
      table {
        border-collapse: collapse;
        border-spacing: 0;
      }
      /* End of CSS-reset */
      * {padding: 0; margin: 0;}
      .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
      textarea.emscripten { font-family: monospace; width: 80%; }
      div.emscripten { text-align: center; }
      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten { border: 0px none; background-color: #0F0F0F; width: 100%; height: 100%; }
      /* Browser not supported message */

      p {
        font-size: 32pt;
      }

      h2 {
        font-weight: normal;
        font-size: 48pt;
        margin-bottom: 20px;
      }

      div#message {
        width: 100%;
        height: 100%;
        position:absolute;
        top:0;
        left:0;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      div#message div {
        text-align: center;
        padding: 20px;
        color: #E5E5E5;
        background-color: transparent;
      }

      div#message div a {
        color: white;
        display: inline;
      }

      div#message div a.linkBtn {
        font-size: 76px;
        display: block;
        text-align: center;
        padding: 20px;
        text-decoration: none;
        color: #222;
        background-color: white;
        box-shadow: 0px 2px 0 rgba(0, 0, 0, 0.3), 2px 4px 1px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
      }

      div#message div a.linkBtn:last-child {
        margin-bottom: 0;
      }

      div#message img {
        width: auto;
        height: 100px;
        display: inline-block;
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>

    <div>
      <!-- <input type="text" id="text-input" style="display: none;" /> -->
      <input id="text-input" type="text" />
      <textarea id="text-area"></textarea>
    </div>

    <div id="message">
      <div>
        <img src="app-logo.svg" />
        <h2 id="message_title">Loading<span id="dot1">.</span><span id="dot2">.</span><span id="dot3">.</span></h2>
        <p id="message_content"></p>
      </div>
    </div>

    <div id="android" style="display: none;">
      <img src="app-logo.svg" />
      <p id="android_title">Want to play on Android? 🙂</p>
      <p id="android_content"> <a href="https://play.google.com/store/apps/details?id=com.voxowl.pcubes.android" class="linkBtn">Get on Play Store</a>
        <a href="https://app.cu.bzh/" class="linkBtn">Open in app</a></p>
    </div>

    <div id="ios" style="display: none;">
      <img src="app-logo.svg" />
      <p id="ios_title">Want to play on iOS? 🙂</p>
      <p id="ios_content"><a href="https://testflight.apple.com/join/7iMxzKht" class="linkBtn">Get on TestFlight</a>
        <a href="https://app.cu.bzh/" class="linkBtn">Open in app</a></p>
    </div>

    <div id="browser" style="display: none;">
      <img src="app-logo.svg" />
      <p id="browser_title">Web browser not supported 😱</p>
      <p id="browser_content">We recommend using&nbsp;<a href="https://www.google.com/intl/en_en/chrome/">Google Chrome</a>&nbsp;or&nbsp;<a href="https://www.mozilla.org/en-US/firefox/new/">Mozilla Firefox</a>.</p>
    </div>

    <div style="width: 100%; height: 100%;">
      <canvas class="emscripten" id="canvas" tabindex=-1 oncontextmenu="event.preventDefault()"></canvas>
      <textarea id="clipboard" style="width:0;height:0;border:0;position:fixed" aria-hidden="true"></textarea>
    </div>

    <script type='text/javascript'>
      let loadingIndicator = document.getElementById('message');
      let msgTitle = document.getElementById('message_title');
      let dots = [document.getElementById('dot1'), document.getElementById('dot2'), document.getElementById('dot3')]
      let msgContent = document.getElementById('message_content');

      t = 0
      const loadingTick = setInterval(function() {
        t++; if (t > 3) { t = 0 }
        for (i = 0; i < 3; i++) {
          dots[i].style.opacity = (i < t ? "1.0" : "0.1")
        }
      },  100)

      function isWebBrowserSupported() {
          if (navigator.userAgent.indexOf("Chrome") != -1 ||
              navigator.userAgent.indexOf("Firefox") != -1 ||
              navigator.userAgent.indexOf("Safari") != -1) {
              return true;
          }
          return false;
          // if((navigator.userAgent.indexOf("Opera") || navigator.userAgent.indexOf('OPR')) != -1 )
          // else if(navigator.userAgent.indexOf("Edg") != -1 )
          // else if(navigator.userAgent.indexOf("Chrome") != -1 )
          // else if(navigator.userAgent.indexOf("Safari") != -1)
          // else if((navigator.userAgent.indexOf("MSIE") != -1 ) || (!!document.documentMode == true )) //IF IE > 10
      }

      function isIOS() {
        return [
          'iPad Simulator',
          'iPhone Simulator',
          'iPod Simulator',
          'iPad',
          'iPhone',
          'iPod'
        ].includes(navigator.platform)
        // iPad on iOS 13 detection
        || (navigator.userAgent.includes("Mac") && "ontouchend" in document)
      }
      
      function showAndroidLinks() {
        msgTitle.innerHTML = document.getElementById("android_title").innerHTML;
        msgContent.innerHTML = document.getElementById("android_content").innerHTML;
      }

      function showIOSMessage() {
        msgTitle.innerHTML = document.getElementById("ios_title").innerHTML;
        msgContent.innerHTML = document.getElementById("ios_content").innerHTML;
      }

      function showBrowserSupportMessage() {
        msgTitle.innerHTML = document.getElementById("browser_title").innerHTML;
        msgContent.innerHTML = document.getElementById("browser_content").innerHTML;
      }

      function initAndMountFS() {
          return new Promise(function(resolve, reject) {
              // Setup and mount persistent storage.
              // Make a directory other than '/'
              FS.mkdir('/storage');
              FS.mount(IDBFS, {}, '/storage');

              // Then mount with IDBFS type
              // Mount folders used at runtime

              // Then sync
              // true means storage -> emscripten FS
              // false means emscripten -> storage
              let populate = true;
              FS.syncfs(populate, function(err) {
                  resolve(err);
              });
          });
      }

      var Module = {
        preInit: [async function() {
          let err = await initAndMountFS();
          console.log("[Cubzh][FS] initAndMountFS: ", err == null ? "OK" : "ERROR (" + err + ")")
        }],
        preRun: [],
        postRun: [],
        print: (function() {})(),
        printErr: function(text) {
          if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          if (0) { // XXX disabled for safety typeof dump == 'function') {
            dump(text + '\n'); // fast, straight to the real console
          } else {
            console.error(text);
          }
        },
        canvas: (function() {
          var canvas = document.getElementById('canvas');

          // As a default initial behavior, pop up an alert when webgl context is lost. To make your
          // application robust, you may want to override this behavior before shipping!
          // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
          canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);

          return canvas;
        })(),
        hideLoadingIndicator: function() { 
          clearInterval(loadingTick)
          loadingIndicator.style.display = "none"
        },
      };

      window.onerror = function(message, source, lineno, colno, error) {
        // Module.setStatus('Exception thrown, see JavaScript console');
        // we need vx-wrapper to extract message from a C++ thrown exception
        if (typeof error === 'number') {
          Module.printErr('[Error ' + error + ' message] ' + Module.getExceptionMessage(error));
        } else {
          Module.printErr(message);
        }
      };

      function launch() {
        if (navigator.userAgent.toLowerCase().includes("android")) {
          clearInterval(loadingTick)
          showAndroidLinks();
          return;
        }

        if (isIOS()) {
          clearInterval(loadingTick)
          showIOSMessage();
          return;
        }

        if (isWebBrowserSupported() == false) {
          clearInterval(loadingTick)
          showBrowserSupportMessage();
          return;
        }

        // everything is ok, launch web version!
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = "cubzh.js";
        s.async = true;
        var t = document.getElementsByTagName('script')[0];
        t.parentNode.appendChild(s);
      }

      // String to UTF8 bytes
      function convertSelectionFromStringToUTF8Bytes(text, cursorStart, cursorEnd) {
        // Check if the indices are valid
        if (cursorStart < 0 || cursorEnd > text.length || cursorStart > cursorEnd) {
          throw new Error("Invalid indices")
        }

        const substrBeforeSelectionStart = text.substring(0, cursorStart)
        const utf8BytesBeforeStart = new TextEncoder().encode(substrBeforeSelectionStart)
        if (cursorStart === cursorEnd) {
          return [utf8BytesBeforeStart.length, utf8BytesBeforeStart.length]
        }
        const substrSelection = text.substring(cursorStart, cursorEnd)
        const utf8BytesSelection = new TextEncoder().encode(substrSelection)
        return [utf8BytesBeforeStart.length, utf8BytesBeforeStart.length+utf8BytesSelection.length]
      }

      // UTF8 bytes to string
      function convertSelectionFromUTF8BytesToString(utf8Bytes, cursorStart, cursorEnd) {
        // Check if the indices are valid
        if (cursorStart < 0 || cursorEnd > utf8Bytes.length || cursorStart > cursorEnd) {
          throw new Error("Invalid indices")
        }

        const bytesBeforeStart = utf8Bytes.slice(0, cursorStart)
        const strBeforeStart = new TextDecoder().decode(new Uint8Array(bytesBeforeStart))

        if (cursorStart === cursorEnd) {
          return [strBeforeStart.length, strBeforeStart.length]
        }

        const bytesBetweenStartAndEnd = utf8Bytes.slice(cursorStart, cursorEnd)
        const strBetweenStartAndEnd = new TextDecoder().decode(new Uint8Array(bytesBetweenStartAndEnd))

        return [strBeforeStart.length, strBeforeStart.length + strBetweenStartAndEnd.length]
      }

      // Add an event listener to the input field for the 'input' event
      {
        let textInput = document.getElementById("text-input");

        // callback function
        function updateCursorPosition() {
          const text = textInput.value;
          // Convert cursor positon to UTF-8 bytes position
          const cursorInBytes = convertSelectionFromStringToUTF8Bytes(text, textInput.selectionStart, textInput.selectionEnd)
          // Notify the C/C++ layer
          Module.textInputUpdate(text, cursorInBytes[0], cursorInBytes[1])
        }

        textInput.vxEnableEvents = function() {

          this.addEventListener('input', function() {
            // console.log("⚡️ ON INPUT")
            updateCursorPosition();
          });


          this.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) {
              console.log("⚡️ ON KEYDOWN : ENTER")
              Module.keyEventDown(e.key, e.code, e.ctrlKey, e.shiftKey, e.altKey, e.metaKey);
            }
          });
          
          this.addEventListener('keyup', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) {
              console.log("⚡️ ON KEYUP : ENTER")
              Module.keyEventUp(e.key, e.code, e.ctrlKey, e.shiftKey, e.altKey, e.metaKey);
            } else {
              updateCursorPosition();
            }
          });
        }

        textInput.vxEnableEvents();

        // textInput.vxEventReceived = function() {
        //   const cursorStart = textInput.selectionStart;
        //   const cursorEnd = textInput.selectionEnd;
        //   const text = textInput.value;
        //   // Notify the C/C++ code of the change
        //   Module.textInputUpdate(text, cursorStart, cursorEnd)
        // }

        // function onClick() {
        //   console.log("⚡️ ON CLICK")
        //   textInput.focus();
        //   updateCursorPosition();
        // }

        // textInput.vxDisableEvents = function() {
        //   // console.log("⚡️ DISABLE")
        //   this.removeEventListener('input', updateCursorPosition);
        //   this.removeEventListener('click', updateCursorPosition);
        //   this.removeEventListener('keyup', updateCursorPosition);
        // }

        // // callback function
        // function updateCursorPosition() {
        //   const cursorStart = textInput.selectionStart;
        //   const cursorEnd = textInput.selectionEnd;
        //   const text = textInput.value;

        //   console.log("⭐️ DISABLED NOTIF:", document.getElementById("text-input").disableNotif)

        //   // Notify the C/C++ code of the change
        //   Module.textInputUpdate(text, cursorStart, cursorEnd)
        // }

        // // Add event listeners to the input field for various events
        // textInput.addEventListener('input', updateCursorPosition);
        // // textInput.addEventListener('keydown', updateCursorPosition);
        // textInput.addEventListener('keyup', updateCursorPosition);
        // textInput.addEventListener('click', updateCursorPosition);
      }

      launch();

    </script>
    <!-- Build fails when removing this, but we don't need to script to be embedded,
      in fact, loading it after all checks is better, within launch() -->
    <!-- {{{ SCRIPT }}} -->
  </body>
</html>
